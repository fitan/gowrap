package {{$.name}}

import (
	"context"
	"fmt"
	"github.com/fitan/mykit/mygorm"
	"go.uber.org/zap"

	"github.com/pkg/errors"
)

type Middleware func(Service) Service

// @tags {{$.name}}
// @base-path /{{$.name}}
// @impl
//go:generate gk gen -g "myHttp:http.go" -g "myEndpoint:endpoint.go" -g "myLog:log.go" -g "myTrace:trace.go" -g "dto:dto.go" -p true
type Service interface {
	// Create 创建
	// @kit-http / POST
	// @kit-http-request CreateRequest body
	Create(ctx context.Context, createRequest CreateRequest) (res bool, err error)
	// Update 更新
	// @kit-http /{uuid} PUT
	// @kit-http-request UpdateRequest
	Update(ctx context.Context, uuid string, body CreateRequest) (res bool, err error)
	// Delete 删除
	// @kit-http /{uuid} DELETE
	// @kit-http-request DeleteRequest
	Delete(ctx context.Context, uuid string) (res bool, err error)
	// List 列表
	// @kit-http / GET
	// @kit-http-request ListRequest
	List(ctx context.Context, page int, pageSize int, order string, query listQuery) (list []GetResponse, total int64, err error)
	// Get 获取
	// @kit-http /{uuid} GET
	// @kit-http-request GetRequest
	Get(ctx context.Context, uuid string) (res GetResponse, err error)
	// Filter 过滤
	// @kit-http /filter GET
	// @kit-http-request FilterRequest
	Filter(ctx context.Context, key, value string, query filterQuery) (res []map[string]interface{}, err error)
}

type BaseService struct {
	DB 	   *mygorm.DB
	Log     *zap.SugaredLogger
	Repository repo.Services
}


func (s *BaseService) Filter(ctx context.Context, key, value string, query filterQuery) (res []map[string]interface{}, err error) {
	dbName,ok := DbNameMap[key]
	if !ok {
		err = fmt.Errorf("key %s not found", key)
		return
	}

	// @call query
	queryScope := filterQueryDTO(query)

	vs, err := s.Repository.{{UpFirst $.name}}.Filter(ctx, dbName, value, queryScope)
	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.Filter")
		return
	}

	for _, v := range vs {
		c := make(map[string]interface{}, 0)
		c["uuid"] = v["uuid"]
		c[key] = v[dbName]

		res = append(res, c)
	}

	return
}

func (s *BaseService) Get(ctx context.Context, uuid string) (res GetResponse, err error) {
	get, err := s.Repository.{{UpFirst $.name}}.Get(ctx, uuid)
	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.Get")
		return
	}

	// @call copy
	res = getCopyDTO(get)

	return
}

func (s *BaseService) Create(ctx context.Context, createRequest CreateRequest) (res bool, err error) {
	var create types.{{UpFirst $.name}}
	// @call copy
	create = createCopyDTO(createRequest)

	err = s.Repository.{{UpFirst $.name}}.Create(ctx, create)

	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.Create")
		return false, err
	}

	return true, nil
}

func (s *BaseService) Update(ctx context.Context, uuid string, createRequest CreateRequest) (res bool, err error) {
	var update types.{{UpFirst $.name}}
	// @call copy
	update = updateCopyDTO(createRequest)

	err = s.Repository.{{UpFirst $.name}}.Update(ctx, uuid, update)
	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.Update")
		return false, err
	}

	return true, nil
}

func (s *BaseService) Delete(ctx context.Context, uuid string) (res bool, err error) {
	err = s.Repository.{{UpFirst $.name}}.Delete(ctx, uuid)
	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.Delete")
		return false, err
	}

	err = s.Repository.{{UpFirst $.name}}.Delete(ctx, uuid)
	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.Delete")
		return false, err
	}

	return true, nil
}

func (s *BaseService) List(ctx context.Context, page int, pageSize int, order string,query listQuery) (list []GetResponse, total int64, err error) {
	// @call query
	queryScope := listQueryDTO(query)

	res, total, err := s.Repository.{{UpFirst $.name}}.List(ctx, page, pageSize, order, queryScope)
	if err != nil {
		err = errors.Wrap(err, "{{UpFirst $.name}}.List")
		return nil, 0, err
	}

	// @call copy
	list = listDTO(res)

	return
}

type BaseServiceImpl Service

