import (
	"context"
	"github.com/fitan/gink/transport/http"
	"github.com/gin-gonic/gin"
	{{range $i := $.Imports}}
    {{$i}}
    {{end}}
)

{{/* gotype: github.com/fitan/gowrap/generator.TemplateInputs */}}

type Ops map[string][]http.ServerOption


func AddHttpOptionToAllMethods(options map[string][]http.ServerOption, option http.ServerOption) {
	methods := []string{
{{range $method := .Interface.Methods}}
{{if $method.HasGin}}
		"{{$method.Name}}",
{{end}}
{{end}}
	}
	for _, v := range methods {
		options[v] = append(options[v], option)
	}
}

type HttpHandler struct {

}

func NewHTTPHandler(r *gin.Engine, endpoints Endpoints, options Ops) HttpHandler {
{{range $method := .Interface.Methods}}
{{if $method.HasGin}}
	make{{$method.Name}}Handler(r, endpoints, options["{{$method.Name}}"])
{{end}}
{{end}}
    return HttpHandler{}
}

type SwagResponse struct {
	TraceId string `json:"traceId"`
	Data interface{} `json:"data"`
}

{{range $method := .Interface.Methods}}
{{if $method.HasGin}}
{{if $method.Gin.HasQuery}}
type {{$method.Gin.QueryRawStructName}} {{$method.Gin.QueryRawStruct}}
{{end}}
{{if $method.Gin.HasBody}}
type {{$method.Gin.BodyRawStructName}} {{$method.Gin.BodyRawStruct}}
{{end}}

// @Accept  json
// @Tags {{$.Interface.Name}} {{if $method.Gin.HasBody}}
// @Param body body {{$method.Gin.BodyRawStructName}} true " " {{- end}}{{if $method.Gin.HasQuery}}
// @Param query query {{$method.Gin.QueryRawStructName}} false " "{{- end}}{{if $method.Gin.HasUri}}{{- range $TagMsg := $method.Gin.UriTagMsgs}}
// @Param {{$TagMsg.TagValue}} path string true "{{$TagMsg.Comment}} "{{- end}}{{end}}{{- if $method.Gin.HasHeader}}{{- range $TagMsg := $method.Gin.HeaderTagMsgs}}
// @Param {{$TagMsg.TagValue}} header string false "{{$TagMsg.Comment}} "{{- end}}{{end}}
// @Success 200 {object} SwagResponse{data={{replace (index $method.Results 0).Type "*" ""}}}
// @Router {{$method.Gin.SwagUrl}} [{{down $method.Gin.Method}}]
func make{{$method.Name}}Handler(r *gin.Engine, endpoints Endpoints, options []http.ServerOption) {
	r.{{up $method.Gin.Method}}("{{$method.Gin.Url}}", http.NewServer(endpoints.{{$method.Name}}Endpoint, decode{{$method.Name}}Request, http.EncodeJSONResponse, options...).ServeHTTP)
}

func decode{{$method.Name}}Request(_ context.Context, ctx *gin.Context) (interface{}, error) {
	var req {{(index $method.Params 1).Type}}
	var err error
	{{if $method.Gin.HasQuery}}
	err = ctx.ShouldBindQuery(&req.Query)
    if err != nil {
    	return nil, err
    }
	{{end}}
	{{if $method.Gin.HasUri}}
	err = ctx.ShouldBindUri(&req.Uri)
    if err != nil {
    	return nil, err
    }
	{{end}}
	{{if $method.Gin.HasHeader}}
	err = ctx.ShouldBindHeader(&req.Header)
    if err != nil {
    	return nil, err
    }
	{{end}}
	{{if $method.Gin.HasBody}}
	err = ctx.ShouldBindJSON(&req.Body)
    if err != nil {
    	return nil, err
    }
	{{end}}

	return req, err
}
{{end}}
{{end}}