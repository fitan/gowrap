{{/* gotype: github.com/fitan/gowrap/generator.TemplateInputs */}}

package {{$.Vars.pkgName}}

import (
	"context"
	"fmt"

	"github.com/go-kit/kit/log"
	"github.com/pkg/errors"
)

type Middleware func(Service) Service

// @tags {{$.Vars.pkgName}}
// @basePath /{{$.Vars.pkgName}}
//
//go:generate gowrap gen -g -p ./ -i Service -bt "kit_http:http.go kit_endpoint:endpoint.go ce_log:logging.go ce_trace:tracing.go"
type Service interface {
	// Create 创建
	// @kit-http / POST
	// @kit-http-request CreateRequest body
	Create(ctx context.Context, createRequest CreateRequest) (res bool, err error)
	// Update 更新
	// @kit-http /{uuid} PUT
	// @kit-http-request UpdateRequest
	Update(ctx context.Context, uuid string, body CreateRequest) (res bool, err error)
	// Delete 删除
	// @kit-http /{uuid} DELETE
	// @kit-http-request DeleteRequest
	Delete(ctx context.Context, uuid string) (res bool, err error)
	// List 列表
	// @kit-http / GET
	// @kit-http-request ListRequest
	List(ctx context.Context, page int, pageSize int,match Match) (list []GetResponse, total int64, err error)
	// Get 获取
	// @kit-http /{uuid} GET
	// @kit-http-request GetRequest
	Get(ctx context.Context, uuid string) (res GetResponse, err error)
	// Filter 过滤
	// @kit-http /filter GET
	// @kit-http-request FilterRequest
	Filter(ctx context.Context, key, value string, match Match) (res FilterResponse, err error)
}

type service struct {
	traceId    string
	logger     log.Logger
	repository repository.Repository
}


func (s *service) Filter(ctx context.Context, key, value string, match Match) (res FilterResponse, err error) {
	dbName,ok := DbNameMap[key]
	if !ok {
		err = fmt.Errorf("key %s not found", key)
		return
	}
	vs, err := s.repository.{{$.Vars.objName}}().Filter(ctx, dbName, value, match.DTO())
	if err != nil {
		err = errors.Wrap(err, "{{$.Vars.objName}}.Filter")
		return
	}

	for _, v := range vs {
		c := make(map[string]interface{}, 0)
		c["uuid"] = v["uuid"]
		c[key] = v[dbName]

		res = append(res, c)
	}

	return
}

func (s *service) Get(ctx context.Context, uuid string) (res GetResponse, err error) {
	v, err := s.repository.{{$.Vars.objName}}().Get(ctx, uuid)
	if err != nil {
		err = errors.Wrap(err, "{{$.Vars.objName}}.Get")
		return
	}

	res = res.DTO(v)
	return
}

func (s *service) Create(ctx context.Context, createRequest CreateRequest) (res bool, err error) {
	err = s.repository.{{$.Vars.objName}}().Create(ctx, createRequest.DTO())

	if err != nil {
		err = errors.Wrap(err, "{{$.Vars.objName}}.Create")
		return false, err
	}

	return true, nil
}

func (s *service) Update(ctx context.Context, uuid string, createRequest CreateRequest) (res bool, err error) {
	err = s.repository.{{$.Vars.objName}}().Update(ctx, uuid, createRequest.DTO())
	if err != nil {
		err = errors.Wrap(err, "{{$.Vars.objName}}.Update")
		return
	}

	return true, nil
}

func (s *service) Delete(ctx context.Context, uuid string) (res bool, err error) {
	err = s.repository.{{$.Vars.objName}}().Delete(ctx, uuid)
	if err != nil {
		err = errors.Wrap(err, "{{$.Vars.objName}}.Delete")
		return false, err
	}

	return true, nil
}

func (s *service) List(ctx context.Context, page int, pageSize int,match Match) (list []GetResponse, total int64, err error) {
	res, total, err := s.repository.{{$.Vars.objName}}().List(ctx, page, pageSize, "", match.DTO(), match.Where())
	if err != nil {
		err = errors.Wrap(err, "{{$.Vars.objName}}.List")
		return nil, 0, err
	}

	dto := GetResponse{}
	for _, v := range res {
		list = append(list, dto.DTO(v))
	}

	return
}

func New(logger log.Logger, traceId string, repository repository.Repository) Service {
	logger = log.With(logger, "{{$.Vars.pkgName}}", "service")
	return &service{
		traceId:    traceId,
		logger:     logger,
		repository: repository,
	}
}
