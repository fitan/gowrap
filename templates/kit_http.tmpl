{{/* gotype: github.com/fitan/gowrap/generator.TemplateInputs */}}
import (
"encoding/json"
"net/http"
"strings"

valid "github.com/asaskevich/govalidator"
"github.com/go-kit/kit/endpoint"
kithttp "github.com/go-kit/kit/transport/http"
"github.com/gorilla/mux"
"github.com/pkg/errors"
"github.com/spf13/cast"

{{range $i := $.Imports}}
    {{$i}}
{{end}}
)

func MakeHTTPHandler(s Service, dmw []endpoint.Middleware, opts []kithttp.ServerOption) http.Handler {
	var ems []endpoint.Middleware

	opts = append(opts, kithttp.ServerBefore(func(ctx context.Context, request *http.Request) context.Context {
		return ctx
	}))

	ems = append(ems, dmw...)

	eps := NewEndpoint(s, map[string][]endpoint.Middleware{
		{{range $m := $.Interface.Methods}}
		"{{$m.Name}}": ems,
		{{end}}
	})

	r := mux.NewRouter()

	{{range $m := $.Interface.Methods}}
	r.Handle("{{$m.KitConf.Conf.Url}}", kithttp.NewServer(
		eps.{{$m.Name}}Endpoint,
		decode{{$m.Name}}Request,
		kithttp.EncodeJSONResponse,
		opts...,
	)).Methods("{{up $m.KitConf.Conf.UrlMethod}}")
	{{end}}

	return r
}

{{range $m := $.Interface.Methods}}
// {{$m.KitRequest.ServiceName}}
// @Summary
// @Description
// @Tags {{$.Interface.Name}}
// @Accept json
// @Produce json
{{- range $k,$v := $m.KitRequest.Path}}
// @Param {{$v.ParamName}} path {{$v.BasicType}} true {{$v.Annotations}}
{{- end}}
{{- range $k, $v := $m.KitRequest.Query}}
// @Param {{$v.ParamName}} query {{if eq $v.ParamType "slice"}}[]{{end}}{{$v.BasicType}} false {{$v.Annotations}}
{{- end}}
{{- range $k, $v := $m.KitRequest.Header}}
// @Param {{$v.ParamName}} header {{$v.BasicType}} false {{$v.Annotations}}
{{- end}}
// @Success 200 {object} encode.Response{data={{(index $m.Results 0).Type}}}
// @Router {{$m.KitConf.Conf.Url}} [{{$m.KitConf.Conf.UrlMethod}}]
{{$m.KitRequestDecode}}
{{end}}
